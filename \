import axios from "axios";
import ModeSelection from "../../components/play/ModeSelection";
import TypingBox from "../../components/play/TypingBox";
import PromptDisplay from "../../components/play/PromptDisplay";
import { useState, useEffect, useRef } from "react";

const SinglePlayer = () => {
  const [prompt, setPrompt] = useState("");
  const [inputLog, setInputLog] = useState([]); // rawText: {char, time, type}
  const [testStarted, setTestStarted] = useState(false);
  const [startTime, setStartTime] = useState(null);
  const [testFinished, setTestFinished] = useState(false);
  const [result, setResult] = useState(null); // wpm, accuracy, etc.
  const [mode, setMode] = useState({}); // "word" or "timer"
  const [duration, setDuration] = useState(60); // timer mode: seconds
  const [wordCount, setWordCount] = useState(50); // word mode
  const [rawText, setRawText] = useState([]);
  const [typedText, setTypedText] = useState("");
  const [loadingPrompt, setLoadingPrompt] = useState(false);
  const [error, setError] = useState(null);
  const [remaining, setRemaining] = useState(600);

  const intervalRef = useRef(null);

  // Start countdown when startTime is set
  useEffect(() => {
    if (!startTime || mode.type === "count") return;

    const endTime = startTime + mode.val * 1000; // 60s timer
    intervalRef.current = setInterval(() => {
      const remaining = Math.max(0, Math.ceil((endTime - Date.now()) / 1000));
      setRemaining(remaining);

      if (remaining === 0) {
        clearInterval(intervalRef.current);
        handleComplete();
      }
    }, 250); // run every 1/4 second for accuracy

    return () => clearInterval(intervalRef.current);
  }, [startTime]);
  useEffect(() => {
    setTypedText("");
    setRawText([]);
    setStartTime(null);
    console.log(mode);
    setTestFinished(false);
    const fetchPrompt = async () => {
      try {
        setLoadingPrompt(true);
        setError(null);

        const res = await axios.get("/api/typing/prompt", {
          params:
            mode.type === "timer"
              ? { type: "classic", timer: duration }
              : { type: "classic", count: wordCount },
        });

        setPrompt(res.data.prompt);
      } catch (err) {
        console.error(err);
        setError(err.response?.data?.message || "Failed to load prompt");
      } finally {
        setLoadingPrompt(false);
      }
    };

    fetchPrompt();
  }, [mode, duration, wordCount]);

  const handleComplete = () => {
    setTestFinished(true);
    setStartTime(null);
    clearInterval(intervalRef.current); // ðŸ”¥ Stop timer
    console.log("Test Complete");
    console.log(rawText);
  };

  return (
    <div className="flex flex-col justify-center items-center h-max w-full m-20 ">
      <div className="w-7xl">
        <h1 className="text-4xl">
          {" "}
          {startTime && mode.type === "timer"
            ? `${remaining} s`
            : "Start Typing...."}
        </h1>

        <ModeSelection
          onSelect={(selectedValue) => {
            const [type, val] = selectedValue.split("_");
            setMode({ type: type, val: val }); // "timer" or "count"
            if (type === "timer") setDuration(Number(val));
            else setWordCount(Number(val));
          }}
        />
      </div>
      <div>
        {testFinished ? (
          <h1>Test Finished </h1>
        ) : (
          <>
            <PromptDisplay
              prompt={prompt}
              typedText={typedText}
              startTime={startTime}
              mode={mode}
            />
            <TypingBox
              prompt={prompt}
              mode={mode}
              typedText={typedText}
              setTypedText={setTypedText}
              startTime={startTime}
              setStartTime={setStartTime}
              wordCount={wordCount}
              onInput={(entry) => {
                setRawText((prev) => [...prev, entry]);
                console.log(typedText);
              }}
              onComplete={() => handleComplete()}
            />
          </>
        )}
      </div>
    </div>
  );
};

export default SinglePlayer;
